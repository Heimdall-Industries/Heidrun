"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.sendTokens = exports.confirmTokenBalance = exports.createMint = exports.mintTokens = exports.createAssociatedTokenAccountInstruction = exports.createRequestUnitsInstruction = exports.Numberu32 = exports.createATokenAccount = exports.getAtaForMint = void 0;
var anchor_1 = require("@project-serum/anchor");
var spl_token_1 = require("@solana/spl-token");
var _1 = require(".");
var assert_1 = require("assert");
var bn_js_1 = __importDefault(require("bn.js"));
/**
 * Returns a program address and bump seed of an associated token account for a designated mint
 *
 * @param mint - Asset mint
 * @param buyer
 */
function getAtaForMint(mint, buyer) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, anchor_1.web3.PublicKey.findProgramAddress([
                    buyer.toBuffer(),
                    spl_token_1.TOKEN_PROGRAM_ID.toBuffer(),
                    mint.toBuffer()
                ], spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID)];
        });
    });
}
exports.getAtaForMint = getAtaForMint;
/**
 *  Create a new account to hold tokens from the provided mint.
 *
 * @param provider
 * @param mint - Asset mint to create token account for
 * @param payer (Optional - if not provided, defaults to provider wallet)
 * @param owner (Optional - if not provided, defaults to provider wallet)
 */
function createATokenAccount(provider, mint, payer, owner) {
    return __awaiter(this, void 0, void 0, function () {
        var associatedTokenAccount, tx, ix, txid;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    payer = payer || provider.wallet.publicKey;
                    owner = owner || provider.wallet.publicKey;
                    return [4 /*yield*/, getAtaForMint(mint, owner)];
                case 1:
                    associatedTokenAccount = (_a.sent())[0];
                    tx = new anchor_1.web3.Transaction();
                    return [4 /*yield*/, createAssociatedTokenAccountInstruction(associatedTokenAccount, payer, owner, mint)];
                case 2:
                    ix = _a.sent();
                    tx.add(ix);
                    return [4 /*yield*/, provider.send(tx)];
                case 3:
                    txid = _a.sent();
                    console.log('Created Token Account: ', txid);
                    return [2 /*return*/, associatedTokenAccount];
            }
        });
    });
}
exports.createATokenAccount = createATokenAccount;
var Numberu32 = /** @class */ (function (_super) {
    __extends(Numberu32, _super);
    function Numberu32() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Convert to Buffer representation
     */
    Numberu32.prototype.toBuffer = function () {
        var a = _super.prototype.toArray.call(this).reverse();
        var b = Buffer.from(a);
        if (b.length === 4) {
            return b;
        }
        var zeroPad = Buffer.alloc(4);
        b.copy(zeroPad);
        return zeroPad;
    };
    /**
     * Construct a Numberu32 from Buffer representation
     */
    Numberu32.fromBuffer = function (buffer) {
        return new bn_js_1["default"](__spreadArray([], buffer).reverse()
            .map(function (i) { return ("00" + i.toString(16)).slice(-2); })
            .join(''), 16);
    };
    return Numberu32;
}(bn_js_1["default"]));
exports.Numberu32 = Numberu32;
/**
 * Request more compute units for solana transcations
*/
function createRequestUnitsInstruction(payer) {
    return __awaiter(this, void 0, void 0, function () {
        var maxUnits, instruction0, buffer, instruction;
        return __generator(this, function (_a) {
            maxUnits = new Numberu32(1000000);
            instruction0 = Buffer.from([0]);
            buffer = maxUnits.toBuffer();
            instruction = new anchor_1.web3.TransactionInstruction({
                keys: [{ pubkey: payer, isSigner: true, isWritable: true }],
                programId: new anchor_1.web3.PublicKey('ComputeBudget111111111111111111111111111111'),
                data: Buffer.concat([instruction0, buffer])
            });
            return [2 /*return*/, instruction];
        });
    });
}
exports.createRequestUnitsInstruction = createRequestUnitsInstruction;
/**
 * Returns an instruction which can be used to create an associated token account for a designated mint
 *
 * @param payer
 * @param owner
 * @param mint - Asset mint to create token account for
 */
function createAssociatedTokenAccountInstruction(associatedTokenAccount, payer, owner, mint) {
    return __awaiter(this, void 0, void 0, function () {
        var keys, txInstruction;
        return __generator(this, function (_a) {
            keys = [
                {
                    pubkey: payer,
                    isSigner: true,
                    isWritable: true
                },
                {
                    pubkey: associatedTokenAccount,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: owner,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: mint,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: anchor_1.web3.SystemProgram.programId,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: spl_token_1.TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: anchor_1.web3.SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
            ];
            txInstruction = new anchor_1.web3.TransactionInstruction({
                keys: keys,
                programId: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
                data: Buffer.from([])
            });
            return [2 /*return*/, txInstruction];
        });
    });
}
exports.createAssociatedTokenAccountInstruction = createAssociatedTokenAccountInstruction;
/**
 * Mints tokens to associated token account
 *
 * @param provider
 * @param mint - Asset mint
 * @param destinationTokenAccount - Account for minted tokens to be deposited into
 * @param amount - Desired number of tokens to be minted
 * @param mintAuthority - Publickey of mint authority
 */
function mintTokens(provider, mint, destinationTokenAccount, amount, mintAuthority) {
    return __awaiter(this, void 0, void 0, function () {
        var tx, txid;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    tx = new anchor_1.web3.Transaction();
                    mintAuthority = mintAuthority || provider.wallet.publicKey;
                    tx.add(spl_token_1.Token.createMintToInstruction(spl_token_1.TOKEN_PROGRAM_ID, mint, destinationTokenAccount, mintAuthority, [], amount));
                    return [4 /*yield*/, provider.send(tx)];
                case 1:
                    txid = _a.sent();
                    return [2 /*return*/, txid];
            }
        });
    });
}
exports.mintTokens = mintTokens;
/**
 * Creates a new account and calls the Token program to initialize the account as a mint.
 *
 * @param provider
 * @param decimals - Number of decimals in token account amount
 */
function createMint(provider, decimals, mintAuthority, freezeAuthority) {
    return __awaiter(this, void 0, void 0, function () {
        var account, tx, lamps, createAccountInstruction, initialInstruction, txid;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    account = anchor_1.web3.Keypair.generate();
                    tx = new anchor_1.web3.Transaction();
                    return [4 /*yield*/, provider.connection.getMinimumBalanceForRentExemption(spl_token_1.MintLayout.span)];
                case 1:
                    lamps = _a.sent();
                    mintAuthority = mintAuthority || provider.wallet.publicKey;
                    freezeAuthority = freezeAuthority || provider.wallet.publicKey;
                    createAccountInstruction = anchor_1.web3.SystemProgram.createAccount({
                        fromPubkey: provider.wallet.publicKey,
                        newAccountPubkey: account.publicKey,
                        lamports: lamps,
                        space: spl_token_1.MintLayout.span,
                        programId: spl_token_1.TOKEN_PROGRAM_ID
                    });
                    tx.add(createAccountInstruction);
                    initialInstruction = spl_token_1.Token.createInitMintInstruction(spl_token_1.TOKEN_PROGRAM_ID, account.publicKey, decimals, mintAuthority, freezeAuthority);
                    tx.add(initialInstruction);
                    return [4 /*yield*/, provider.send(tx, [account])];
                case 2:
                    txid = _a.sent();
                    console.log('Created mint: ', txid);
                    return [2 /*return*/, account.publicKey];
            }
        });
    });
}
exports.createMint = createMint;
/**
 * Asserts that the balance of a token account matches the provided expected quantity
 *
 * @param provider - Connection/wallet context
 * @param tokenAccount - Public key of account to be confirmed
 * @param expectedQuantity - Expected number of tokens in account
 */
function confirmTokenBalance(provider, tokenAccount, expectedQuantity, confirmClosed) {
    return __awaiter(this, void 0, void 0, function () {
        var tokenData, tokenAmount;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, provider.connection.getAccountInfo(tokenAccount, 'recent')];
                case 1:
                    tokenData = _a.sent();
                    // Confirm account is closed
                    if (confirmClosed === true) {
                        assert_1.strict(tokenData === null);
                    }
                    if (tokenData !== null) {
                        tokenAmount = _1.byteArrayToLong(tokenData.data.slice(64, 72));
                        assert_1.strict(tokenAmount == expectedQuantity, "On-chain Token amount of " + tokenAmount + " does not match expected amount " + expectedQuantity);
                    }
                    else {
                        console.log('Token account %s does not exist', tokenAccount.toString());
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.confirmTokenBalance = confirmTokenBalance;
/**
 * Transfers tokens between designated wallets and retursn a transaction signature.
 *
 * @param provider - Connection/wallet context
 * @param fromWallet - Source account
 * @param toWallet - Destination account
 * @param amount - Number of tokens to transfer
 */
function sendTokens(provider, // Keep provider or add connection and pass in owner?
fromWallet, toWallet, amount) {
    return __awaiter(this, void 0, void 0, function () {
        var tx, txid;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    tx = new anchor_1.web3.Transaction();
                    tx.add(spl_token_1.Token.createTransferInstruction(spl_token_1.TOKEN_PROGRAM_ID, fromWallet, toWallet, provider.wallet.publicKey, [], amount));
                    return [4 /*yield*/, provider.send(tx)];
                case 1:
                    txid = _a.sent();
                    return [2 /*return*/, txid];
            }
        });
    });
}
exports.sendTokens = sendTokens;
//# sourceMappingURL=scoreHelpers.js.map