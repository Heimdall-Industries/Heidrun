"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.closeAccountsInstruction = exports.createWithdrawShipsInstruction = exports.createWithdrawArmsInstruction = exports.createWithdrawFoodInstruction = exports.createWithdrawFuelInstruction = exports.createHarvestInstruction = exports.createSettleInstruction = exports.createRepairInstruction = exports.createRefuelInstruction = exports.createRefeedInstruction = exports.createRearmInstruction = exports.createPartialDepositInstruction = exports.createInitialDepositInstruction = exports.createUpdateRewardRateInstruction = exports.createDeregisterShipInstruction = exports.createRegisterShipInstruction = exports.createScoreVarsInitializeInstruction = exports.getAllFleetsForUserPublicKey = exports.getAllFleets = exports.getAllRegisteredShips = exports.getScoreTreasuryAuthAccount = exports.getScoreTreasuryTokenAccount = exports.getScoreVarsShipInfo = exports.decodeEvent = exports.getShipStakingAccountInfo = exports.getScoreVarsInfo = exports.getShipStakingAccount = exports.getScoreEscrowAuthAccount = exports.getScoreEscrowAccount = exports.getScoreVarsShipAccount = exports.getScoreVarsAccount = exports.getScoreIDL = void 0;
var anchor_1 = require("@project-serum/anchor");
var spl_token_1 = require("@solana/spl-token");
var web3_js_1 = require("@solana/web3.js");
var _1 = require(".");
var scoreIdl_1 = require("./util/scoreIdl");
var scoreLogIdl_1 = require("./util/scoreLogIdl");
var factionProgramId = new anchor_1.web3.PublicKey('FACTNmq2FhA2QNTnGM2aWJH3i7zT3cND5CgvjYTjyVYe');
/**
 * Returns the base IDL for the SCORE program following as generated by Anchor with provided program ID appended to metadata.
 *
 * @param programId - Deployed program ID for the SCORE program
 * @returns - The base IDL object
 */
function getScoreIDL(programId) {
    var _tmp = scoreIdl_1.baseIdl;
    _tmp['metadata']['address'] = programId.toBase58();
    return _tmp;
}
exports.getScoreIDL = getScoreIDL;
/**
 * Returns the public key and bump seed for the SCORE variables account.
 *
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Public key, bump seed]
 */
function getScoreVarsAccount(programId) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, anchor_1.web3.PublicKey.findProgramAddress([
                    Buffer.from('SCOREVARS')
                ], programId)];
        });
    });
}
exports.getScoreVarsAccount = getScoreVarsAccount;
/**
 * Returns the public key and bump seed for the SCORE variables ship account associated with the provided ship mint.
 *
 * @param programId - Deployed program ID for the SCORE program
 * @param shipMint - Ship mint address
 * @returns - [Ship account public key, bump seed]
 */
function getScoreVarsShipAccount(programId, shipMint) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, anchor_1.web3.PublicKey.findProgramAddress([
                    Buffer.from('SCOREVARS_SHIP'),
                    shipMint.toBuffer()
                ], programId)];
        });
    });
}
exports.getScoreVarsShipAccount = getScoreVarsShipAccount;
/**
 * Returns the public key and bump seed for a user's SCORE escrow account.
 *
 * @param programId - Deployed program ID for the SCORE program
 * @param shipMint - Ship mint address
 * @param resourceMint - Mint address for the desired R4 resource
 * @param playerPublicKey - Player's public key
 * @returns - [Escrow account public key, bump seed]
 */
function getScoreEscrowAccount(programId, shipMint, resourceMint, playerPublicKey) {
    return __awaiter(this, void 0, void 0, function () {
        var seeds;
        return __generator(this, function (_a) {
            seeds = [
                Buffer.from('SCORE_ESCROW'),
                playerPublicKey.toBuffer(),
                shipMint.toBuffer()
            ];
            if (resourceMint !== null) {
                seeds.push(resourceMint.toBuffer());
            }
            return [2 /*return*/, anchor_1.web3.PublicKey.findProgramAddress(seeds, programId)];
        });
    });
}
exports.getScoreEscrowAccount = getScoreEscrowAccount;
/**
 * Returns the SCORE escrow authority account
 *
 * @param programId - Deployed program ID for the SCORE program
 * @param shipMint - Ship mint address
 * @param playerPublicKey - Player's public key
 * @returns - [Authority account public key, bump seed]
 */
function getScoreEscrowAuthAccount(programId, shipMint, playerPublicKey) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, anchor_1.web3.PublicKey.findProgramAddress([
                    Buffer.from('SCORE_ESCROW_AUTHORITY'),
                    playerPublicKey.toBuffer(),
                    shipMint.toBuffer()
                ], programId)];
        });
    });
}
exports.getScoreEscrowAuthAccount = getScoreEscrowAuthAccount;
/**
 * Returns a user's ship staking account
 *
 * @param programId - Deployed program ID for the SCORE program
 * @param assetMint - Mint address for the desired resource
 * @param playerPublicKey - Player's public key
 * @returns - [Staking account public key, bump seed]
 */
function getShipStakingAccount(programId, assetMint, playerPublicKey) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, anchor_1.web3.PublicKey.findProgramAddress([
                    Buffer.from('SCORE_INFO'),
                    playerPublicKey.toBuffer(),
                    assetMint.toBuffer(),
                ], programId)];
        });
    });
}
exports.getShipStakingAccount = getShipStakingAccount;
/**
 * Returns the current SCORE variables info.
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 */
function getScoreVarsInfo(connection, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var provider, idl, program, scoreVarsAccount, obj;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    provider = new anchor_1.Provider(connection, null, null);
                    idl = getScoreIDL(programId);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 1:
                    scoreVarsAccount = (_a.sent())[0];
                    return [4 /*yield*/, program.account.scoreVars.fetch(scoreVarsAccount)];
                case 2:
                    obj = _a.sent();
                    return [2 /*return*/, obj];
            }
        });
    });
}
exports.getScoreVarsInfo = getScoreVarsInfo;
/**
 * Returns the current ship staking account info for a player and ship mint.
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 * @param shipMint - ship mint address
 * @param playerPublicKey - Player's public key
 */
function getShipStakingAccountInfo(connection, programId, shipMint, playerPublicKey) {
    return __awaiter(this, void 0, void 0, function () {
        var provider, idl, program, shipStakingAccount, obj;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    provider = new anchor_1.Provider(connection, null, null);
                    idl = getScoreIDL(programId);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    shipStakingAccount = (_a.sent())[0];
                    return [4 /*yield*/, program.account.shipStaking.fetch(shipStakingAccount)];
                case 2:
                    obj = _a.sent();
                    return [2 /*return*/, obj];
            }
        });
    });
}
exports.getShipStakingAccountInfo = getShipStakingAccountInfo;
/**
 * Returns decoded event
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 * @param event - Event to decode
 */
function decodeEvent(connection, programId, event) {
    return __awaiter(this, void 0, void 0, function () {
        var provider, program;
        return __generator(this, function (_a) {
            provider = new anchor_1.Provider(connection, null, null);
            program = new anchor_1.Program(scoreLogIdl_1.scoreLogBaseIdl, programId, provider);
            return [2 /*return*/, program.coder.events.decode(event)];
        });
    });
}
exports.decodeEvent = decodeEvent;
/**
 * Returns the current SCORE variables info for a designated ship mint.
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 * @param shipMint - Ship mint address
 */
function getScoreVarsShipInfo(connection, programId, shipMint) {
    return __awaiter(this, void 0, void 0, function () {
        var provider, idl, program, scoreVarsShipAccount, obj;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    provider = new anchor_1.Provider(connection, null, null);
                    idl = getScoreIDL(programId);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 1:
                    scoreVarsShipAccount = (_a.sent())[0];
                    return [4 /*yield*/, program.account.scoreVarsShip.fetch(scoreVarsShipAccount)];
                case 2:
                    obj = _a.sent();
                    return [2 /*return*/, obj];
            }
        });
    });
}
exports.getScoreVarsShipInfo = getScoreVarsShipInfo;
/**
 * Returns the public key and bump seed for the SCORE treasury token account.
 *
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Treasury's Public key, bump seed]
 */
function getScoreTreasuryTokenAccount(programId) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, anchor_1.web3.PublicKey.findProgramAddress([
                    Buffer.from('SCORE_TREASURY')
                ], programId)];
        });
    });
}
exports.getScoreTreasuryTokenAccount = getScoreTreasuryTokenAccount;
/**
 * Returns the treasury authority account
 *
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Authority account public key, bump seed]
 */
function getScoreTreasuryAuthAccount(programId) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, anchor_1.web3.PublicKey.findProgramAddress([
                    Buffer.from('SCORE_TREASURY_AUTHORITY'),
                ], programId)];
        });
    });
}
exports.getScoreTreasuryAuthAccount = getScoreTreasuryAuthAccount;
/**
 * Returns a list registered ships
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Ship Staking Account Infos]
 */
function getAllRegisteredShips(connection, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var idl, provider, program, _shipsRegistered, shipsRegistered, _i, _shipsRegistered_1, ship;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, program.account.scoreVarsShip.all()];
                case 1:
                    _shipsRegistered = _a.sent();
                    shipsRegistered = [];
                    for (_i = 0, _shipsRegistered_1 = _shipsRegistered; _i < _shipsRegistered_1.length; _i++) {
                        ship = _shipsRegistered_1[_i];
                        shipsRegistered.push(ship.account);
                    }
                    return [2 /*return*/, shipsRegistered];
            }
        });
    });
}
exports.getAllRegisteredShips = getAllRegisteredShips;
/**
 * Returns a list of all fleets
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Ship Staking Account Infos]
 */
function getAllFleets(connection, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var idl, provider, program, _shipStakingAccounts, shipStakingAccounts, _i, _shipStakingAccounts_1, stakingAccount;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, program.account.shipStaking.all()];
                case 1:
                    _shipStakingAccounts = _a.sent();
                    shipStakingAccounts = [];
                    for (_i = 0, _shipStakingAccounts_1 = _shipStakingAccounts; _i < _shipStakingAccounts_1.length; _i++) {
                        stakingAccount = _shipStakingAccounts_1[_i];
                        shipStakingAccounts.push(stakingAccount.account);
                    }
                    return [2 /*return*/, shipStakingAccounts];
            }
        });
    });
}
exports.getAllFleets = getAllFleets;
/**
 * Returns a list of player deployed fleets to the SCORE program
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Ship Staking Account Infos]
 */
function getAllFleetsForUserPublicKey(connection, playerPublicKey, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var idl, provider, program, shipsRegistered, playerShipStakingAccounts, _i, shipsRegistered_1, ship, playerShipStakingAccount, _playerFleets, playerFleets;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, program.account.scoreVarsShip.all()];
                case 1:
                    shipsRegistered = _a.sent();
                    playerShipStakingAccounts = [];
                    _i = 0, shipsRegistered_1 = shipsRegistered;
                    _a.label = 2;
                case 2:
                    if (!(_i < shipsRegistered_1.length)) return [3 /*break*/, 5];
                    ship = shipsRegistered_1[_i];
                    return [4 /*yield*/, getShipStakingAccount(programId, ship.account.shipMint, playerPublicKey)];
                case 3:
                    playerShipStakingAccount = (_a.sent())[0];
                    playerShipStakingAccounts.push(playerShipStakingAccount);
                    _a.label = 4;
                case 4:
                    _i++;
                    return [3 /*break*/, 2];
                case 5: return [4 /*yield*/, program.account.shipStaking.fetchMultiple(playerShipStakingAccounts)];
                case 6:
                    _playerFleets = _a.sent();
                    playerFleets = _playerFleets
                        .filter(function (fleet) { return fleet !== null; })
                        .map(function (fleet) { return fleet; });
                    return [2 /*return*/, playerFleets];
            }
        });
    });
}
exports.getAllFleetsForUserPublicKey = getAllFleetsForUserPublicKey;
/**
 * Initializes Score variables account and creates ATLAS treasury token account
 *
 * @param connection - web3.Connection object
 * @param updateAuthorityAccount - Desired authority public key
 * @param atlasMint - ATLAS mint address
 * @param fuelMint - Fuel mint address
 * @param foodMint - Food mint address
 * @param armsMint - Arms mint address
 * @param toolkitMint - Toolkit mint address
 * @param programId - Deployed program ID for the SCORE program
 */
function createScoreVarsInitializeInstruction(connection, updateAuthorityAccount, atlasMint, fuelMint, foodMint, armsMint, toolkitMint, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var idl, provider, program, _a, treasuryTokenAccount, treasuryBump, _b, treasuryAuthorityAccount, treasuryAuthBump, _c, scoreVarsAccount, scoreVarsBump, ix;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, getScoreTreasuryTokenAccount(programId)];
                case 1:
                    _a = _d.sent(), treasuryTokenAccount = _a[0], treasuryBump = _a[1];
                    return [4 /*yield*/, getScoreTreasuryAuthAccount(programId)];
                case 2:
                    _b = _d.sent(), treasuryAuthorityAccount = _b[0], treasuryAuthBump = _b[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 3:
                    _c = _d.sent(), scoreVarsAccount = _c[0], scoreVarsBump = _c[1];
                    return [4 /*yield*/, program.instruction.processInitialize(scoreVarsBump, treasuryBump, treasuryAuthBump, {
                            accounts: {
                                updateAuthorityAccount: updateAuthorityAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                systemProgram: web3_js_1.SystemProgram.programId,
                                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
                                treasuryTokenAccount: treasuryTokenAccount,
                                treasuryAuthorityAccount: treasuryAuthorityAccount,
                                atlasMint: atlasMint,
                                fuelMint: fuelMint,
                                foodMint: foodMint,
                                armsMint: armsMint,
                                toolkitMint: toolkitMint
                            },
                            signers: []
                        })];
                case 4:
                    ix = _d.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.createScoreVarsInitializeInstruction = createScoreVarsInitializeInstruction;
/**
 * Initiates Score variables account for a provided ship mint.
 *
 * @param connection - web3.Connection object
 * @param updateAuthorityAccount - valid authority public key
 * @param shipMint - Ship mint address
 * @param fuelMaxReserve - Max fuel in token units
 * @param foodMaxReserve - Max food in token units
 * @param armsMaxReserve - Max arms in token units
 * @param toolkitMaxReserve - Max toolkits in token units
 * @param millisecondsToBurnFuel - the amount of milliseconds to burn one fuel token
 * @param millisecondsToBurnFood - the amount of milliseconds to burn one food token
 * @param millisecondsToBurnArms - the amount of milliseconds to burn one arms token
 * @param millisecondsToBurnToolkit - the amount of milliseconds to burn one toolkit token
 * @param rewardRatePerSecond - Atlas rewarded per second
 * @param programId - Deployed Score program ID
 */
function createRegisterShipInstruction(connection, updateAuthorityAccount, shipMint, fuelMaxReserve, foodMaxReserve, armsMaxReserve, toolkitMaxReserve, millisecondsToBurnFuel, millisecondsToBurnFood, millisecondsToBurnArms, millisecondsToBurnToolkit, rewardRatePerSecond, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var idl, provider, program, _a, scoreVarsShipAccount, scoreVarsShipBump, _b, scoreVarsAccount, scoreVarsBump, ix;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 1:
                    _a = _c.sent(), scoreVarsShipAccount = _a[0], scoreVarsShipBump = _a[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 2:
                    _b = _c.sent(), scoreVarsAccount = _b[0], scoreVarsBump = _b[1];
                    return [4 /*yield*/, program.instruction.processRegisterShip(scoreVarsBump, scoreVarsShipBump, new anchor_1.BN(rewardRatePerSecond), fuelMaxReserve, foodMaxReserve, armsMaxReserve, toolkitMaxReserve, millisecondsToBurnFuel, millisecondsToBurnFood, millisecondsToBurnArms, millisecondsToBurnToolkit, {
                            accounts: {
                                updateAuthorityAccount: updateAuthorityAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                shipMint: shipMint,
                                systemProgram: web3_js_1.SystemProgram.programId
                            },
                            signers: []
                        })];
                case 3:
                    ix = _c.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.createRegisterShipInstruction = createRegisterShipInstruction;
/**
 * Deregister a ship that was already registered (Admin only)
 * Only to be called in the event of an invalid register
 *
 * @param connection - web3.Connection object
 * @param updateAuthorityAccount - valid authority public key
 * @param shipMint - Ship mint address
 * @param programId - Deployed Score program ID
 */
function createDeregisterShipInstruction(connection, updateAuthorityAccount, shipMint, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var idl, provider, program, _a, scoreVarsShipAccount, scoreVarsShipBump, _b, scoreVarsAccount, scoreVarsBump, ix;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 1:
                    _a = _c.sent(), scoreVarsShipAccount = _a[0], scoreVarsShipBump = _a[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 2:
                    _b = _c.sent(), scoreVarsAccount = _b[0], scoreVarsBump = _b[1];
                    return [4 /*yield*/, program.instruction.processDeregisterShip(scoreVarsBump, scoreVarsShipBump, {
                            accounts: {
                                updateAuthorityAccount: updateAuthorityAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                shipMint: shipMint
                            },
                            signers: []
                        })];
                case 3:
                    ix = _c.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.createDeregisterShipInstruction = createDeregisterShipInstruction;
/**
 * Update a ship's reward rate (Admin only)
 *
 * @param connection - web3.Connection object
 * @param updateAuthorityAccount - valid authority public key
 * @param shipMint - Ship mint address
 * @param newRewardRatePerSecond - New Atlas rewards per second in base units
 * @param programId - Deployed Score program ID
 */
function createUpdateRewardRateInstruction(connection, updateAuthorityAccount, shipMint, newRewardRatePerSecond, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var idl, provider, program, _a, scoreVarsShipAccount, scoreVarsShipBump, _b, scoreVarsAccount, scoreVarsBump, ix;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 1:
                    _a = _c.sent(), scoreVarsShipAccount = _a[0], scoreVarsShipBump = _a[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 2:
                    _b = _c.sent(), scoreVarsAccount = _b[0], scoreVarsBump = _b[1];
                    return [4 /*yield*/, program.instruction.processUpdateRewardRate(scoreVarsBump, scoreVarsShipBump, new anchor_1.BN(newRewardRatePerSecond), {
                            accounts: {
                                updateAuthorityAccount: updateAuthorityAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                shipMint: shipMint
                            },
                            signers: []
                        })];
                case 3:
                    ix = _c.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.createUpdateRewardRateInstruction = createUpdateRewardRateInstruction;
/**
 * Provides a transaction instruction which can be used to deposit a specified quantity of ships to a player's ship staking account.
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param shipQuantity - Quantity to deposit as u64
 * @param shipMint - Ship mint address
 * @param shipTokenAccount - Token account for the ship resource being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
function createInitialDepositInstruction(connection, playerPublicKey, shipQuantity, shipMint, shipTokenAccount, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, escrowAuthority, escrowAuthBump, _b, shipEscrow, escrowBump, _c, shipStakingAccount, stakingBump, _d, scoreVarsShipAccount, scoreVarsShipBump, playerFactionPDA, idl, provider, program, ix;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0: return [4 /*yield*/, getScoreEscrowAuthAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _e.sent(), escrowAuthority = _a[0], escrowAuthBump = _a[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, null, playerPublicKey)];
                case 2:
                    _b = _e.sent(), shipEscrow = _b[0], escrowBump = _b[1];
                    return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 3:
                    _c = _e.sent(), shipStakingAccount = _c[0], stakingBump = _c[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 4:
                    _d = _e.sent(), scoreVarsShipAccount = _d[0], scoreVarsShipBump = _d[1];
                    return [4 /*yield*/, _1.getPlayerFactionPDA(playerPublicKey, factionProgramId)];
                case 5:
                    playerFactionPDA = (_e.sent())[0];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, program.instruction.processInitialDeposit(stakingBump, scoreVarsShipBump, escrowAuthBump, escrowBump, new anchor_1.BN(shipQuantity), {
                            accounts: {
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                playerFactionAccount: playerFactionPDA,
                                escrowAuthority: escrowAuthority,
                                systemProgram: anchor_1.web3.SystemProgram.programId,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
                                shipMint: shipMint,
                                shipTokenAccountSource: shipTokenAccount,
                                shipTokenAccountEscrow: shipEscrow
                            }
                        })];
                case 6:
                    ix = _e.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.createInitialDepositInstruction = createInitialDepositInstruction;
/**
 * Provides a transaction instruction which can be used to deposit a specified quantity of ships to an already deployed player's ship staking account.
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param shipQuantity - Quantity to deposit as u64
 * @param shipMint - Ship mint address
 * @param shipTokenAccount - Token account for the ship resource being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
function createPartialDepositInstruction(connection, playerPublicKey, shipQuantity, shipMint, shipTokenAccount, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, escrowAuthority, escrowAuthBump, _b, shipEscrow, escrowBump, _c, shipStakingAccount, stakingBump, _d, scoreVarsShipAccount, scoreVarsShipBump, idl, provider, program, ix;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0: return [4 /*yield*/, getScoreEscrowAuthAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _e.sent(), escrowAuthority = _a[0], escrowAuthBump = _a[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, null, playerPublicKey)];
                case 2:
                    _b = _e.sent(), shipEscrow = _b[0], escrowBump = _b[1];
                    return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 3:
                    _c = _e.sent(), shipStakingAccount = _c[0], stakingBump = _c[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 4:
                    _d = _e.sent(), scoreVarsShipAccount = _d[0], scoreVarsShipBump = _d[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, program.instruction.processPartialDeposit(stakingBump, scoreVarsShipBump, escrowAuthBump, escrowBump, new anchor_1.BN(shipQuantity), {
                            accounts: {
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                escrowAuthority: escrowAuthority,
                                systemProgram: anchor_1.web3.SystemProgram.programId,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                shipMint: shipMint,
                                shipTokenAccountSource: shipTokenAccount,
                                shipTokenAccountEscrow: shipEscrow
                            }
                        })];
                case 5:
                    ix = _e.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.createPartialDepositInstruction = createPartialDepositInstruction;
/**
 * Provides a transaction instruction which can be used to transfer arms resources to a player's arms escrow account.
 *
 * @param connection - web3.Connection object
 * @param tokenOwnerPublickey - Resource Token Account Owner
 * @param playerPublicKey - Player's public key
 * @param armsQuantity - Arms resource quantity as u64
 * @param shipMint - Ship mint address
 * @param armsMint - Arms resource mint address
 * @param armsTokenAccount - Token account for the arms resources being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
function createRearmInstruction(connection, tokenOwnerPublickey, playerPublicKey, armsQuantity, shipMint, armsMint, armsTokenAccount, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, escrowAuthority, escrowAuthBump, _b, armsEscrow, escrowBump, _c, shipStakingAccount, stakingBump, _d, scoreVarsShipAccount, scoreVarsShipBump, _e, scoreVarsAccount, scoreVarsBump, idl, provider, program, ix;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0: return [4 /*yield*/, getScoreEscrowAuthAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _f.sent(), escrowAuthority = _a[0], escrowAuthBump = _a[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, armsMint, playerPublicKey)];
                case 2:
                    _b = _f.sent(), armsEscrow = _b[0], escrowBump = _b[1];
                    return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 3:
                    _c = _f.sent(), shipStakingAccount = _c[0], stakingBump = _c[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 4:
                    _d = _f.sent(), scoreVarsShipAccount = _d[0], scoreVarsShipBump = _d[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 5:
                    _e = _f.sent(), scoreVarsAccount = _e[0], scoreVarsBump = _e[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, program.instruction.processRearm(stakingBump, scoreVarsBump, scoreVarsShipBump, escrowAuthBump, escrowBump, new anchor_1.BN(armsQuantity), {
                            accounts: {
                                tokenOwnerAccount: tokenOwnerPublickey,
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                escrowAuthority: escrowAuthority,
                                systemProgram: anchor_1.web3.SystemProgram.programId,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
                                shipMint: shipMint,
                                armsMint: armsMint,
                                armsTokenAccountSource: armsTokenAccount,
                                armsTokenAccountEscrow: armsEscrow
                            }
                        })];
                case 6:
                    ix = _f.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.createRearmInstruction = createRearmInstruction;
/**
 * Provides a transaction instruction which can be used to transfer food resources to a player's food escrow account.
 *
 * @param connection - web3.Connection object
 * @param tokenOwnerPublickey - Resource Token Account Owner
 * @param playerPublicKey - Player's public key
 * @param foodQuantity - Food resource quantity as u64
 * @param shipMint - Ship mint address
 * @param foodMint - Food resource mint address
 * @param foodTokenAccount - Token account for the food resource being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
function createRefeedInstruction(connection, tokenOwnerPublickey, playerPublicKey, foodQuantity, shipMint, foodMint, foodTokenAccount, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, escrowAuthority, escrowAuthBump, _b, foodEscrow, escrowBump, _c, shipStakingAccount, stakingBump, _d, scoreVarsShipAccount, scoreVarsShipBump, _e, scoreVarsAccount, scoreVarsBump, idl, provider, program, ix;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0: return [4 /*yield*/, getScoreEscrowAuthAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _f.sent(), escrowAuthority = _a[0], escrowAuthBump = _a[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, foodMint, playerPublicKey)];
                case 2:
                    _b = _f.sent(), foodEscrow = _b[0], escrowBump = _b[1];
                    return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 3:
                    _c = _f.sent(), shipStakingAccount = _c[0], stakingBump = _c[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 4:
                    _d = _f.sent(), scoreVarsShipAccount = _d[0], scoreVarsShipBump = _d[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 5:
                    _e = _f.sent(), scoreVarsAccount = _e[0], scoreVarsBump = _e[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, program.instruction.processRefeed(stakingBump, scoreVarsBump, scoreVarsShipBump, escrowAuthBump, escrowBump, new anchor_1.BN(foodQuantity), {
                            accounts: {
                                tokenOwnerAccount: tokenOwnerPublickey,
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                escrowAuthority: escrowAuthority,
                                systemProgram: anchor_1.web3.SystemProgram.programId,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
                                shipMint: shipMint,
                                foodMint: foodMint,
                                foodTokenAccountSource: foodTokenAccount,
                                foodTokenAccountEscrow: foodEscrow
                            }
                        })];
                case 6:
                    ix = _f.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.createRefeedInstruction = createRefeedInstruction;
/**
 * Provides a transaction instruction which can be used to transfer fuel resources to a player's fuel escrow account.
 *
 * @param connection - web3.Connection object
 * @param tokenOwnerPublickey - Resource Token Account Owner
 * @param playerPublicKey - Player's public key
 * @param fuelQuantity - Fuel resource quantity as u64
 * @param shipMint - Ship mint address
 * @param fuelMint - Fuel resource mint address
 * @param fuelTokenAccount - Token account for the fuel resource being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
function createRefuelInstruction(connection, tokenOwnerPublickey, playerPublicKey, fuelQuantity, shipMint, fuelMint, fuelTokenAccount, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, escrowAuthority, escrowAuthBump, _b, fuelEscrow, escrowBump, _c, shipStakingAccount, stakingBump, _d, scoreVarsShipAccount, scoreVarsShipBump, _e, scoreVarsAccount, scoreVarsBump, idl, provider, program, ix;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0: return [4 /*yield*/, getScoreEscrowAuthAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _f.sent(), escrowAuthority = _a[0], escrowAuthBump = _a[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, fuelMint, playerPublicKey)];
                case 2:
                    _b = _f.sent(), fuelEscrow = _b[0], escrowBump = _b[1];
                    return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 3:
                    _c = _f.sent(), shipStakingAccount = _c[0], stakingBump = _c[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 4:
                    _d = _f.sent(), scoreVarsShipAccount = _d[0], scoreVarsShipBump = _d[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 5:
                    _e = _f.sent(), scoreVarsAccount = _e[0], scoreVarsBump = _e[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, program.instruction.processRefuel(stakingBump, scoreVarsBump, scoreVarsShipBump, escrowAuthBump, escrowBump, new anchor_1.BN(fuelQuantity), {
                            accounts: {
                                tokenOwnerAccount: tokenOwnerPublickey,
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                escrowAuthority: escrowAuthority,
                                systemProgram: anchor_1.web3.SystemProgram.programId,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
                                shipMint: shipMint,
                                fuelMint: fuelMint,
                                fuelTokenAccountSource: fuelTokenAccount,
                                fuelTokenAccountEscrow: fuelEscrow
                            }
                        })];
                case 6:
                    ix = _f.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.createRefuelInstruction = createRefuelInstruction;
/**
 * Provides a transaction instruction which can be used to transfer toolkit resources to a player's toolkit escrow account.
 *
 * @param connection - web3.Connection object
 * @param tokenOwnerPublickey - Resource Token Account Owner
 * @param playerPublicKey - Player's public key
 * @param toolkitQuantity - Toolkit resource quantity as u64
 * @param shipMint - Ship mint address
 * @param toolkitMint - Toolkit resource mint address
 * @param toolkitTokenAccount - Token account for the toolkit resource being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
function createRepairInstruction(connection, tokenOwnerPublickey, playerPublicKey, toolkitQuantity, shipMint, toolkitMint, toolkitTokenAccount, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, shipStakingAccount, stakingBump, _b, scoreVarsShipAccount, scoreVarsShipBump, _c, scoreVarsAccount, scoreVarsBump, idl, provider, program, ix;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0: return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _d.sent(), shipStakingAccount = _a[0], stakingBump = _a[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 2:
                    _b = _d.sent(), scoreVarsShipAccount = _b[0], scoreVarsShipBump = _b[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 3:
                    _c = _d.sent(), scoreVarsAccount = _c[0], scoreVarsBump = _c[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, program.instruction.processRepair(stakingBump, scoreVarsBump, scoreVarsShipBump, new anchor_1.BN(toolkitQuantity), {
                            accounts: {
                                tokenOwnerAccount: tokenOwnerPublickey,
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                systemProgram: anchor_1.web3.SystemProgram.programId,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
                                shipMint: shipMint,
                                toolkitMint: toolkitMint,
                                toolkitTokenAccountSource: toolkitTokenAccount
                            }
                        })];
                case 4:
                    ix = _d.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.createRepairInstruction = createRepairInstruction;
/**
 * Returns an instruction that can be used to update the amount of ATLAS in a player's pending rewards and update staked time paid
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param updateAuthorityAccount - valid authority public key
 * @param shipMint - Ship mint address
 * @param programId - Deployed program ID for the SCORE program
 */
function createSettleInstruction(connection, playerPublicKey, updateAuthorityAccount, shipMint, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, shipStakingAccount, stakingBump, _b, scoreVarsShipAccount, scoreVarsShipBump, _c, scoreVarsAccount, scoreVarsBump, idl, provider, program, ix;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0: return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _d.sent(), shipStakingAccount = _a[0], stakingBump = _a[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 2:
                    _b = _d.sent(), scoreVarsShipAccount = _b[0], scoreVarsShipBump = _b[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 3:
                    _c = _d.sent(), scoreVarsAccount = _c[0], scoreVarsBump = _c[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, program.instruction.processSettle(stakingBump, scoreVarsBump, scoreVarsShipBump, {
                            accounts: {
                                playerAccount: playerPublicKey,
                                updateAuthorityAccount: updateAuthorityAccount,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                shipMint: shipMint
                            }
                        })];
                case 4:
                    ix = _d.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.createSettleInstruction = createSettleInstruction;
/**
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param playerAtlasTokenAccount - Player's atlas token account public key TODO: can replace with getAtaForMint once we have ATLAS mint address
 * @param atlasMint - Atlas mint address
 * @param shipMint - Ship mint address
 * @param programId - Deployed program ID for the SCORE program
 */
function createHarvestInstruction(connection, playerPublicKey, playerAtlasTokenAccount, atlasMint, shipMint, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, shipStakingAccount, stakingBump, _b, scoreVarsShipAccount, scoreVarsShipBump, _c, treasuryTokenAccount, treasuryBump, _d, treasuryAuthorityAccount, treasuryAuthBump, idl, provider, program, instructions, possibleTokenAccountObj, ix;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0: return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _e.sent(), shipStakingAccount = _a[0], stakingBump = _a[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 2:
                    _b = _e.sent(), scoreVarsShipAccount = _b[0], scoreVarsShipBump = _b[1];
                    return [4 /*yield*/, getScoreTreasuryTokenAccount(programId)];
                case 3:
                    _c = _e.sent(), treasuryTokenAccount = _c[0], treasuryBump = _c[1];
                    return [4 /*yield*/, getScoreTreasuryAuthAccount(programId)];
                case 4:
                    _d = _e.sent(), treasuryAuthorityAccount = _d[0], treasuryAuthBump = _d[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    instructions = [];
                    return [4 /*yield*/, connection.getParsedTokenAccountsByOwner(playerPublicKey, {
                            mint: atlasMint
                        })];
                case 5:
                    possibleTokenAccountObj = _e.sent();
                    // if the token account does not exist, create it
                    if (possibleTokenAccountObj.value.length === 0) {
                        instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, atlasMint, playerAtlasTokenAccount, // token account
                        playerPublicKey, // owner
                        playerPublicKey));
                    }
                    return [4 /*yield*/, program.instruction.processHarvest(stakingBump, scoreVarsShipBump, treasuryBump, treasuryAuthBump, {
                            accounts: {
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                playerAtlasTokenAccount: playerAtlasTokenAccount,
                                treasuryTokenAccount: treasuryTokenAccount,
                                treasuryAuthorityAccount: treasuryAuthorityAccount,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                shipMint: shipMint
                            }
                        })];
                case 6:
                    ix = _e.sent();
                    instructions.push(ix);
                    return [2 /*return*/, instructions];
            }
        });
    });
}
exports.createHarvestInstruction = createHarvestInstruction;
/**
 * Withdraw Fuel from Escrow - required before withdrawShip
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param fuelTokenAccount - Token account for the fuel resource being withdrawn
 * @param fuelMint - Fuel resource mint address
 * @param shipMint - Ship mint address
 * @param programId - Deployed program ID for the SCORE program
 */
function createWithdrawFuelInstruction(connection, playerPublicKey, fuelTokenAccount, fuelMint, shipMint, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, escrowAuthority, escrowAuthBump, _b, fuelEscrow, escrowBump, _c, shipStakingAccount, stakingBump, _d, scoreVarsShipAccount, scoreVarsShipBump, _e, scoreVarsAccount, scoreVarsBump, idl, provider, program, instructions, possibleTokenAccountObj, ix;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0: return [4 /*yield*/, getScoreEscrowAuthAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _f.sent(), escrowAuthority = _a[0], escrowAuthBump = _a[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, fuelMint, playerPublicKey)];
                case 2:
                    _b = _f.sent(), fuelEscrow = _b[0], escrowBump = _b[1];
                    return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 3:
                    _c = _f.sent(), shipStakingAccount = _c[0], stakingBump = _c[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 4:
                    _d = _f.sent(), scoreVarsShipAccount = _d[0], scoreVarsShipBump = _d[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 5:
                    _e = _f.sent(), scoreVarsAccount = _e[0], scoreVarsBump = _e[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    instructions = [];
                    return [4 /*yield*/, connection.getParsedTokenAccountsByOwner(playerPublicKey, {
                            mint: fuelMint
                        })];
                case 6:
                    possibleTokenAccountObj = _f.sent();
                    // if the token account does not exist, create it
                    if (possibleTokenAccountObj.value.length === 0) {
                        instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fuelMint, fuelTokenAccount, // token account
                        playerPublicKey, // owner
                        playerPublicKey));
                    }
                    return [4 /*yield*/, program.instruction.processWithdrawFuel(stakingBump, scoreVarsBump, scoreVarsShipBump, escrowAuthBump, escrowBump, {
                            accounts: {
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                fuelTokenAccountEscrow: fuelEscrow,
                                fuelTokenAccountReturn: fuelTokenAccount,
                                fuelMint: fuelMint,
                                escrowAuthority: escrowAuthority,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                shipMint: shipMint
                            }
                        })];
                case 7:
                    ix = _f.sent();
                    instructions.push(ix);
                    return [2 /*return*/, instructions];
            }
        });
    });
}
exports.createWithdrawFuelInstruction = createWithdrawFuelInstruction;
/**
 * Withdraw Food from Escrow - required before withdrawShip
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param foodTokenAccount - Token account for the food resource being withdrawn
 * @param foodMint - Food resource mint address
 * @param shipMint - Ship mint address
 * @param programId - Deployed program ID for the SCORE program
 */
function createWithdrawFoodInstruction(connection, playerPublicKey, foodTokenAccount, foodMint, shipMint, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, escrowAuthority, escrowAuthBump, _b, foodEscrow, escrowBump, _c, shipStakingAccount, stakingBump, _d, scoreVarsShipAccount, scoreVarsShipBump, _e, scoreVarsAccount, scoreVarsBump, idl, provider, program, instructions, possibleTokenAccountObj, ix;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0: return [4 /*yield*/, getScoreEscrowAuthAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _f.sent(), escrowAuthority = _a[0], escrowAuthBump = _a[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, foodMint, playerPublicKey)];
                case 2:
                    _b = _f.sent(), foodEscrow = _b[0], escrowBump = _b[1];
                    return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 3:
                    _c = _f.sent(), shipStakingAccount = _c[0], stakingBump = _c[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 4:
                    _d = _f.sent(), scoreVarsShipAccount = _d[0], scoreVarsShipBump = _d[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 5:
                    _e = _f.sent(), scoreVarsAccount = _e[0], scoreVarsBump = _e[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    instructions = [];
                    return [4 /*yield*/, connection.getParsedTokenAccountsByOwner(playerPublicKey, {
                            mint: foodMint
                        })];
                case 6:
                    possibleTokenAccountObj = _f.sent();
                    // if the token account does not exist, create it
                    if (possibleTokenAccountObj.value.length === 0) {
                        instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, foodMint, foodTokenAccount, // token account
                        playerPublicKey, // owner
                        playerPublicKey));
                    }
                    return [4 /*yield*/, program.instruction.processWithdrawFood(stakingBump, scoreVarsBump, scoreVarsShipBump, escrowAuthBump, escrowBump, {
                            accounts: {
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                foodTokenAccountEscrow: foodEscrow,
                                foodTokenAccountReturn: foodTokenAccount,
                                foodMint: foodMint,
                                escrowAuthority: escrowAuthority,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                shipMint: shipMint
                            }
                        })];
                case 7:
                    ix = _f.sent();
                    instructions.push(ix);
                    return [2 /*return*/, instructions];
            }
        });
    });
}
exports.createWithdrawFoodInstruction = createWithdrawFoodInstruction;
/**
 * Withdraw Arms from Escrow - required before withdrawShip
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param armsTokenAccount - Token account for the arms resource being withdrawn
 * @param armsMint - Arms resource mint address
 * @param shipMint - Ship mint address
 * @param programId - Deployed program ID for the SCORE program
 */
function createWithdrawArmsInstruction(connection, playerPublicKey, armsTokenAccount, armsMint, shipMint, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, escrowAuthority, escrowAuthBump, _b, armsEscrow, escrowBump, _c, shipStakingAccount, stakingBump, _d, scoreVarsShipAccount, scoreVarsShipBump, _e, scoreVarsAccount, scoreVarsBump, idl, provider, program, instructions, possibleTokenAccountObj, ix;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0: return [4 /*yield*/, getScoreEscrowAuthAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _f.sent(), escrowAuthority = _a[0], escrowAuthBump = _a[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, armsMint, playerPublicKey)];
                case 2:
                    _b = _f.sent(), armsEscrow = _b[0], escrowBump = _b[1];
                    return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 3:
                    _c = _f.sent(), shipStakingAccount = _c[0], stakingBump = _c[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 4:
                    _d = _f.sent(), scoreVarsShipAccount = _d[0], scoreVarsShipBump = _d[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 5:
                    _e = _f.sent(), scoreVarsAccount = _e[0], scoreVarsBump = _e[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    instructions = [];
                    return [4 /*yield*/, connection.getParsedTokenAccountsByOwner(playerPublicKey, {
                            mint: armsMint
                        })];
                case 6:
                    possibleTokenAccountObj = _f.sent();
                    // if the token account does not exist, create it
                    if (possibleTokenAccountObj.value.length === 0) {
                        instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, armsMint, armsTokenAccount, // token account
                        playerPublicKey, // owner
                        playerPublicKey));
                    }
                    return [4 /*yield*/, program.instruction.processWithdrawArms(stakingBump, scoreVarsBump, scoreVarsShipBump, escrowAuthBump, escrowBump, {
                            accounts: {
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                armsTokenAccountEscrow: armsEscrow,
                                armsTokenAccountReturn: armsTokenAccount,
                                armsMint: armsMint,
                                escrowAuthority: escrowAuthority,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                shipMint: shipMint
                            }
                        })];
                case 7:
                    ix = _f.sent();
                    instructions.push(ix);
                    return [2 /*return*/, instructions];
            }
        });
    });
}
exports.createWithdrawArmsInstruction = createWithdrawArmsInstruction;
/**
 * Withdraw Ships from Escrow
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param shipTokenAccount - Token account for the ships to be returned to
 * @param shipMint - Ship mint address
 * @param atlasMint - ATLAS token mint
 * @param toolkitMint - Toolkit resource mint address
 * @param programId - Deployed program ID for the SCORE program
 */
function createWithdrawShipsInstruction(connection, playerPublicKey, playerAtlasTokenAccount, toolkitTokenAccount, shipTokenAccount, shipMint, atlasMint, toolkitMint, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, escrowAuthority, escrowAuthBump, _b, shipEscrow, escrowBump, _c, shipStakingAccount, stakingBump, _d, scoreVarsShipAccount, scoreVarsShipBump, _e, scoreVarsAccount, scoreVarsBump, _f, treasuryTokenAccount, treasuryBump, _g, treasuryAuthorityAccount, treasuryAuthBump, idl, provider, program, instructions, possibleToolkitTokenAccountObj, possibleShipTokenAccountObj, possibleAtlasTokenAccountObj, ix;
        return __generator(this, function (_h) {
            switch (_h.label) {
                case 0: return [4 /*yield*/, getScoreEscrowAuthAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _h.sent(), escrowAuthority = _a[0], escrowAuthBump = _a[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, null, playerPublicKey)];
                case 2:
                    _b = _h.sent(), shipEscrow = _b[0], escrowBump = _b[1];
                    return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 3:
                    _c = _h.sent(), shipStakingAccount = _c[0], stakingBump = _c[1];
                    return [4 /*yield*/, getScoreVarsShipAccount(programId, shipMint)];
                case 4:
                    _d = _h.sent(), scoreVarsShipAccount = _d[0], scoreVarsShipBump = _d[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 5:
                    _e = _h.sent(), scoreVarsAccount = _e[0], scoreVarsBump = _e[1];
                    return [4 /*yield*/, getScoreTreasuryTokenAccount(programId)];
                case 6:
                    _f = _h.sent(), treasuryTokenAccount = _f[0], treasuryBump = _f[1];
                    return [4 /*yield*/, getScoreTreasuryAuthAccount(programId)];
                case 7:
                    _g = _h.sent(), treasuryAuthorityAccount = _g[0], treasuryAuthBump = _g[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    instructions = [];
                    return [4 /*yield*/, connection.getParsedTokenAccountsByOwner(playerPublicKey, {
                            mint: toolkitMint
                        })];
                case 8:
                    possibleToolkitTokenAccountObj = _h.sent();
                    // if the token account does not exist, create it
                    if (possibleToolkitTokenAccountObj.value.length === 0) {
                        instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, toolkitMint, toolkitTokenAccount, // token account
                        playerPublicKey, // owner
                        playerPublicKey));
                    }
                    return [4 /*yield*/, connection.getParsedTokenAccountsByOwner(playerPublicKey, {
                            mint: shipMint
                        })];
                case 9:
                    possibleShipTokenAccountObj = _h.sent();
                    // if the token account does not exist, create it
                    if (possibleShipTokenAccountObj.value.length === 0) {
                        instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, shipMint, shipTokenAccount, // token account
                        playerPublicKey, // owner
                        playerPublicKey));
                    }
                    return [4 /*yield*/, connection.getParsedTokenAccountsByOwner(playerPublicKey, {
                            mint: atlasMint
                        })];
                case 10:
                    possibleAtlasTokenAccountObj = _h.sent();
                    if (possibleAtlasTokenAccountObj.value.length === 0) {
                        instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, atlasMint, playerAtlasTokenAccount, // token account
                        playerPublicKey, // owner
                        playerPublicKey));
                    }
                    return [4 /*yield*/, program.instruction.processWithdrawShips(stakingBump, scoreVarsBump, scoreVarsShipBump, escrowAuthBump, escrowBump, treasuryAuthBump, treasuryBump, {
                            accounts: {
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                scoreVarsShipAccount: scoreVarsShipAccount,
                                playerAtlasTokenAccount: playerAtlasTokenAccount,
                                shipTokenAccountEscrow: shipEscrow,
                                shipTokenAccountReturn: shipTokenAccount,
                                toolkitTokenAccountSource: toolkitTokenAccount,
                                treasuryTokenAccount: treasuryTokenAccount,
                                treasuryAuthorityAccount: treasuryAuthorityAccount,
                                escrowAuthority: escrowAuthority,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                systemProgram: anchor_1.web3.SystemProgram.programId,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                                shipMint: shipMint,
                                toolkitMint: toolkitMint
                            }
                        })];
                case 11:
                    ix = _h.sent();
                    instructions.push(ix);
                    return [2 /*return*/, instructions];
            }
        });
    });
}
exports.createWithdrawShipsInstruction = createWithdrawShipsInstruction;
/**
 * Close all escrow accounts and ship staking accounts
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param shipMint - Ship mint address
 * @param fuelMint - Fuel mint address
 * @param foodMint - Food mint address
 * @param armsMint - Arms mint address
 * @param programId - Deployed program ID for the SCORE program
 */
function closeAccountsInstruction(connection, playerPublicKey, shipMint, fuelMint, foodMint, armsMint, programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, escrowAuthority, escrowAuthBump, _b, shipEscrow, shipBump, _c, fuelEscrow, fuelBump, _d, foodEscrow, foodBump, _e, armsEscrow, armsBump, _f, scoreVarsAccount, scoreVarsBump, _g, shipStakingAccount, stakingBump, idl, provider, program, ix;
        return __generator(this, function (_h) {
            switch (_h.label) {
                case 0: return [4 /*yield*/, getScoreEscrowAuthAccount(programId, shipMint, playerPublicKey)];
                case 1:
                    _a = _h.sent(), escrowAuthority = _a[0], escrowAuthBump = _a[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, null, playerPublicKey)];
                case 2:
                    _b = _h.sent(), shipEscrow = _b[0], shipBump = _b[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, fuelMint, playerPublicKey)];
                case 3:
                    _c = _h.sent(), fuelEscrow = _c[0], fuelBump = _c[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, foodMint, playerPublicKey)];
                case 4:
                    _d = _h.sent(), foodEscrow = _d[0], foodBump = _d[1];
                    return [4 /*yield*/, getScoreEscrowAccount(programId, shipMint, armsMint, playerPublicKey)];
                case 5:
                    _e = _h.sent(), armsEscrow = _e[0], armsBump = _e[1];
                    return [4 /*yield*/, getScoreVarsAccount(programId)];
                case 6:
                    _f = _h.sent(), scoreVarsAccount = _f[0], scoreVarsBump = _f[1];
                    return [4 /*yield*/, getShipStakingAccount(programId, shipMint, playerPublicKey)];
                case 7:
                    _g = _h.sent(), shipStakingAccount = _g[0], stakingBump = _g[1];
                    idl = getScoreIDL(programId);
                    provider = new anchor_1.Provider(connection, null, null);
                    program = new anchor_1.Program(idl, programId, provider);
                    return [4 /*yield*/, program.instruction.processCloseAccounts(stakingBump, scoreVarsBump, shipBump, fuelBump, foodBump, armsBump, escrowAuthBump, {
                            accounts: {
                                playerAccount: playerPublicKey,
                                shipStakingAccount: shipStakingAccount,
                                scoreVarsAccount: scoreVarsAccount,
                                shipTokenAccountEscrow: shipEscrow,
                                fuelTokenAccountEscrow: fuelEscrow,
                                foodTokenAccountEscrow: foodEscrow,
                                armsTokenAccountEscrow: armsEscrow,
                                escrowAuthority: escrowAuthority,
                                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                                systemProgram: anchor_1.web3.SystemProgram.programId,
                                shipMint: shipMint,
                                fuelMint: fuelMint,
                                foodMint: foodMint,
                                armsMint: armsMint,
                                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY
                            }
                        })];
                case 8:
                    ix = _h.sent();
                    return [2 /*return*/, ix];
            }
        });
    });
}
exports.closeAccountsInstruction = closeAccountsInstruction;
//# sourceMappingURL=score.js.map